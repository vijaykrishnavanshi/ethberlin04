{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/metatx/ERC2771Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.9;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder) {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return super._msgData();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/CommunityPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./FileversePortal.sol\";\nimport \"./structs/PortalKeyVerifiers.sol\";\nimport \"./Groth16Verifier.sol\";\n\ncontract CommunityPortal is Groth16Verifier {\n    string public constant name = \"Community Owned Portal\";\n\n    // address of community owned portal\n    FileversePortal public immutable communityPortal;\n    address public owner;\n    address public trustedForwarder = 0x31470b3126DD7cee5ee7591C2cb5142A68F57120;\n\n    // This us the ETHBerlin event UUID converted to bigint\n\tuint256[1] VALID_EVENT_IDS = [\n\t\t111560146890584288369567824893314450802\n\t];\n\n\t// This is hex to bigint conversion for ETHBerlin signer\n\tuint256[2] ETHBERLIN_SIGNER = [\n\t\t13908133709081944902758389525983124100292637002438232157513257158004852609027,\n\t\t7654374482676219729919246464135900991450848628968334062174564799457623790084\n\t];\n\n    struct ProofArgs {\n\t\tuint256[2] _pA;\n\t\tuint256[2][2] _pB;\n\t\tuint256[2] _pC;\n\t\tuint256[38] _pubSignals;\n\t}\n\n    constructor() {\n        owner = address(this);\n        PortalKeyVerifiers.KeyVerifier memory verifier = PortalKeyVerifiers.KeyVerifier(0x0, 0x0, 0x0, 0x0);\n        string memory metadataIPFSHash = \"QmNSM3RTrhhtK8UJESTJYBEWygUHV2DPedxDJfHiVphVVB\";\n        string memory emptyString = \"dummyvalue\";\n        communityPortal = new FileversePortal(\n            metadataIPFSHash,\n            emptyString,\n            emptyString,\n            owner,\n            trustedForwarder,\n            verifier\n        );\n    }\n\n    modifier verifiedProof(ProofArgs calldata proof) {\n\t\trequire(\n\t\t\tthis.verifyProof(\n\t\t\t\tproof._pA,\n\t\t\t\tproof._pB,\n\t\t\t\tproof._pC,\n\t\t\t\tproof._pubSignals\n\t\t\t),\n\t\t\t\"Invalid proof\"\n\t\t);\n\t\t_;\n\t}\n\n    \tmodifier validEventIds(uint256[38] memory _pubSignals) {\n\t\tuint256[] memory eventIds = getValidEventIdFromPublicSignals(\n\t\t\t_pubSignals\n\t\t);\n\t\trequire(\n\t\t\tkeccak256(abi.encodePacked(eventIds)) ==\n\t\t\t\tkeccak256(abi.encodePacked(VALID_EVENT_IDS)),\n\t\t\t\"Invalid event ids\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier validSigner(uint256[38] memory _pubSignals) {\n\t\tuint256[2] memory signer = getSignerFromPublicSignals(_pubSignals);\n\t\trequire(\n\t\t\tsigner[0] == ETHBERLIN_SIGNER[0] && signer[1] == ETHBERLIN_SIGNER[1],\n\t\t\t\"Invalid signer\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier validWaterMark(uint256[38] memory _pubSignals) {\n\t\trequire(\n\t\t\tgetWaterMarkFromPublicSignals(_pubSignals) ==\n\t\t\t\tuint256(uint160(msg.sender)),\n\t\t\t\"Invalid watermark\"\n\t\t);\n\t\t_;\n\t}\n\n    function addCommunityCollaborator(\n        ProofArgs calldata proof,\n        address account\n    ) \n        public\n\t\tverifiedProof(proof)\n\t\tvalidEventIds(proof._pubSignals)\n\t\tvalidSigner(proof._pubSignals)\n    {\n        communityPortal.addCollaborator(account);\n    }\n\n    function isCollaborator(address account) public view returns (bool) {\n        return communityPortal.isCollaborator(account);\n    }\n\n\t// ----------------------------------------------------------\n\t// Utility functions for destructuring a proof publicSignals|\n\t// ----------------------------------------------------------\n\n\tfunction getWaterMarkFromPublicSignals(\n\t\tuint256[38] memory _pubSignals\n\t) public pure returns (uint256) {\n\t\treturn _pubSignals[37];\n\t}\n\n\t// Numbers of events is arbitary but for this example we are using 10 (including test eventID)\n\tfunction getValidEventIdFromPublicSignals(\n\t\tuint256[38] memory _pubSignals\n\t) public view returns (uint256[] memory) {\n\t\t// Events are stored from starting index 15 to till valid event ids length\n\t\tuint256[] memory eventIds = new uint256[](VALID_EVENT_IDS.length);\n\t\tfor (uint256 i = 0; i < VALID_EVENT_IDS.length; i++) {\n\t\t\teventIds[i] = _pubSignals[15 + i];\n\t\t}\n\t\treturn eventIds;\n\t}\n\n\tfunction getSignerFromPublicSignals(\n\t\tuint256[38] memory _pubSignals\n\t) public pure returns (uint256[2] memory) {\n\t\tuint256[2] memory signer;\n\t\tsigner[0] = _pubSignals[13];\n\t\tsigner[1] = _pubSignals[14];\n\t\treturn signer;\n\t}\n}\n"
    },
    "contracts/FileversePortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport \"./structs/PortalKeyVerifiers.sol\";\n\n/// @custom:security-contact security@fileverse.io\ncontract FileversePortal is ERC2771Context, Ownable2Step {\n    using Counters for Counters.Counter;\n\n    // ipfs hash with metadata for portal contract\n    string public metadataIPFSHash;\n\n    // constant for sentinal collaborator\n    address internal constant SENTINEL_COLLABORATOR = address(0x1);\n\n    // mapping with address to collaborator\n    mapping(address => address) internal collaborators;\n\n    // number of collaborator added to the smart contract\n    uint256 internal collaboratorCount;\n\n    // counter instance for fileId\n    Counters.Counter private _fileIdCounter;\n\n    uint256 private _keyVerifierCounter;\n\n    // mapping from version to key verifier hashes\n    mapping(uint256 => PortalKeyVerifiers.KeyVerifier) public keyVerifiers;\n\n    struct CollaboratorKey {\n        string viewDid;\n        string editDid;\n    }\n\n    // mapping from address to the member data\n    mapping(address => CollaboratorKey) public collaboratorKeys;\n    uint256 internal collaboratorKeysCount;\n\n    enum FileType {\n        PUBLIC,\n        PRIVATE,\n        GATED,\n        MEMBER_PRIVATE\n    }\n\n    struct File {\n        string metadataIPFSHash;\n        string contentIPFSHash;\n        string gateIPFSHash;\n        FileType fileType;\n        uint256 version;\n    }\n\n    // mapping from fileId to the file metadata\n    mapping(uint256 => File) public files;\n\n    /**\n     * @notice constructor for the fileverse portal smart contract\n     * @dev It gets called by the mint function of the registry with proper data\n     * @param _metadataIPFSHash - The IPFS hash of the metadata file.\n     * @param _ownerViewDid - The DID of the owner that can be used to view the data\n     * @param _ownerEditDid - The DID of the owner that can be used to edit the data\n     * @param owner - address of the owner which is deploying the smart contract\n     * @param _trustedForwarder - instance of the trusted forwarder\n     */\n    constructor(\n        string memory _metadataIPFSHash,\n        string memory _ownerViewDid,\n        string memory _ownerEditDid,\n        address owner,\n        address _trustedForwarder,\n        PortalKeyVerifiers.KeyVerifier memory _keyVerifier\n    ) ERC2771Context(_trustedForwarder) {\n        require(owner != address(0), \"FV211\");\n        require(_trustedForwarder != address(0), \"FV211\");\n\n        metadataIPFSHash = _metadataIPFSHash;\n        _transferOwnership(owner);\n        _setupCollaborator();\n        _addCollaborator(owner);\n        _addKey(owner, _ownerViewDid, _ownerEditDid);\n        bytes32 portalEncryptionKeyVerifier = _keyVerifier\n            .portalEncryptionKeyVerifier;\n        bytes32 portalDecryptionKeyVerifier = _keyVerifier\n            .portalDecryptionKeyVerifier;\n        bytes32 memberEncryptionKeyVerifier = _keyVerifier\n            .memberEncryptionKeyVerifier;\n        bytes32 memberDecryptionKeyVerifier = _keyVerifier\n            .memberDecryptionKeyVerifier;\n        _addKeyVerifiers(\n            portalEncryptionKeyVerifier,\n            portalDecryptionKeyVerifier,\n            memberEncryptionKeyVerifier,\n            memberDecryptionKeyVerifier\n        );\n    }\n\n    event AddedCollaborator(address indexed account, address indexed by);\n\n    /**\n     * @notice The function adds a collaborator to the list of collaborators\n     * @dev If the collaborator is not the smart contract address and is not\n     * sentinel collaborator and the collaborator is not the zero address,\n     * then add it.\n     * It also emits an event AddedCollaborator with params account and by addresses\n     * It can be called only by the owner of the portal\n     * @param collaborator - The address of the collaborator to be added.\n     */\n    function addCollaborator(address collaborator) public onlyOwner {\n        _addCollaborator(collaborator);\n        emit AddedCollaborator(collaborator, _msgSender());\n    }\n\n    event RemovedCollaborator(address indexed account, address indexed by);\n\n    /**\n     * `function removeCollaborator(address prevCollaborator, address collaborator) public onlyOwner returns (void)`\n     * @notice The function removes a collaborator from the list of collaborators\n     * @dev If the collaborator is not the only collaborator and is not\n     * sentinel collaborator and the collaborator is not the zero address,\n     * then remove it.\n     * It also emits an event RemovedCollaborator with params account and by addresses\n     * It can be called only by the owner of the portal\n     * @param prevCollaborator - The address of the previous collaborator.\n     * @param collaborator - The address of the collaborator to be removed.\n     */\n    function removeCollaborator(address prevCollaborator, address collaborator)\n        public\n        onlyOwner\n    {\n        // Only allow to remove an owner, if greater than one.\n        if (collaboratorCount - 1 == 0) {\n            require(false, \"FV205\");\n        }\n        // Validate owner address and check that it corresponds to owner index.\n        require(\n            collaborator != address(0) &&\n                collaborator != SENTINEL_COLLABORATOR &&\n                collaborator != address(this),\n            \"FV203\"\n        );\n        require(collaborators[prevCollaborator] == collaborator, \"FV204\");\n        CollaboratorKey memory collaboratorKey = collaboratorKeys[collaborator];\n        collaborators[prevCollaborator] = collaborators[collaborator];\n        collaborators[collaborator] = address(0);\n        collaboratorCount--;\n        if (\n            bytes(collaboratorKey.viewDid).length > 0 || bytes(collaboratorKey.editDid).length > 0\n        ) {\n            _removeKey(collaborator);\n        }\n        emit RemovedCollaborator(collaborator, _msgSender());\n    }\n\n    /**\n     * @notice This is a public function to check if an account is a\n     * collaborator or not\n     * @dev If the collaborator is not the sentinel collaborator and\n     * the next collaborator is not the zero address, then return true.\n     * @param account - The address of the account\n     * @return bool - if the address is in collaborator list return true else false.\n     */\n    function isCollaborator(address account) public view returns (bool) {\n        return\n            account != SENTINEL_COLLABORATOR &&\n            collaborators[account] != address(0);\n    }\n\n    /**\n     * `_checkRole(address account)`\n     * @notice Its a function that checks if the address `account` is a\n     * collaborator. If it is not, it reverts the transaction.\n     * @dev This function is used by onlyCollaborator modifier\n     * @param account - The address of the account to check if the ther are a\n     * collaborator\n     */\n    function _checkRole(address account) internal view virtual {\n        if (!isCollaborator(account)) {\n            revert(\"Role Missing\");\n        }\n    }\n\n    /**\n     * `modifier onlyCollaborator()`\n     * @notice This is a modifier that is used to check if the sender is a collaborator.\n     * @dev this modifier is used across the contract. If the sender is not a\n     * collaborator, the transaction is reverted.\n     */\n    modifier onlyCollaborator() {\n        _checkRole(_msgSender());\n        _;\n    }\n\n    /**\n     * `function getCollaborators() public view returns (address[] memory)`\n     * @notice This function is returns the list of collaborator of the portal.\n     * @dev This is read only function which returns a list of addresses\n     * @return collaboratorList - List of addresses that are added as collaborator\n     * to the portal contract\n     */\n    function getCollaborators() public view returns (address[] memory) {\n        address[] memory array = new address[](collaboratorCount);\n\n        // populate return array\n        uint256 index;\n        address currentCollaborator = collaborators[SENTINEL_COLLABORATOR];\n        while (currentCollaborator != SENTINEL_COLLABORATOR) {\n            array[index] = currentCollaborator;\n            currentCollaborator = collaborators[currentCollaborator];\n            index++;\n        }\n        return array;\n    }\n\n    /**\n     * `function getCollaboratorCount() public view returns (uint256)`\n     * @notice This function returns the number of collaborators in the contract\n     * @return collaboratorCount The number of collaborators that are added to the\n     * portal contract\n     */\n    function getCollaboratorCount() public view returns (uint256) {\n        return collaboratorCount;\n    }\n\n    event UpdatedPortalMetadata(string metadataIPFSHash, address indexed by);\n\n    /**\n     * @notice Update the metadata hash of the smart contract. This is what is we\n     * use to show name and description of the portal. It requires that the input\n     * string is not empty and then sets the `metadataIPFSHash` variable to the\n     * input string.\n     * This function can only be called by owner\n     * @dev It also emits an event called `UpdatedPortalMetadata` with the\n     * `metadataIPFSHash` and the `msg.sender` as parameters\n     * @param _metadataIPFSHash - The IPFS hash of the portal metadata file.\n     */\n    function updateMetadata(string memory _metadataIPFSHash) public onlyOwner {\n        require(bytes(_metadataIPFSHash).length != 0, \"FV206\");\n        metadataIPFSHash = _metadataIPFSHash;\n        emit UpdatedPortalMetadata(metadataIPFSHash, _msgSender());\n    }\n\n    event AddedFile(\n        uint256 indexed fileId,\n        string metadataIPFSHash,\n        string contentIPFSHash,\n        string gateIPFSHash,\n        address indexed by\n    );\n\n    /**\n     * @notice Add a file to the smart contract. It requires _metadataIPFSHash and\n     * _contentIPFSHash is not empty.\n     * This function can only be called by a collaborator\n     * @dev An event `event AddedFile` is also emitted at the end. All the data that is\n     * passed as parameters is saved in files mapping.\n     * @param _metadataIPFSHash - The IPFS hash of the metadata file.\n     * @param _contentIPFSHash - The IPFS hash of the file's content.\n     * @param _gateIPFSHash - The IPFS hash of the gate file.\n     * @param filetype - This is an enum that can be one of the following: Public / Private / Gated\n     * @param version - a uint256 which tells which version of the key was used to handle the file\n     */\n    function addFile(\n        string calldata _metadataIPFSHash,\n        string calldata _contentIPFSHash,\n        string calldata _gateIPFSHash,\n        FileType filetype,\n        uint256 version\n    ) public onlyCollaborator {\n        require(bytes(_metadataIPFSHash).length != 0, \"FV206\");\n        require(bytes(_contentIPFSHash).length != 0, \"FV206\");\n        _versionOfKeyVerifierCheck(version);\n\n        if (filetype == FileType.GATED) {\n            require(bytes(_gateIPFSHash).length != 0, \"FV213\");\n        } else {\n            require(bytes(_gateIPFSHash).length == 0, \"FV214\");\n        }\n\n        uint256 fileId = _fileIdCounter.current();\n        _fileIdCounter.increment();\n        files[fileId] = File(\n            _metadataIPFSHash,\n            _contentIPFSHash,\n            _gateIPFSHash,\n            filetype,\n            version\n        );\n        emit AddedFile(\n            fileId,\n            _metadataIPFSHash,\n            _contentIPFSHash,\n            _gateIPFSHash,\n            _msgSender()\n        );\n    }\n\n    event EditedFile(\n        uint256 indexed fileId,\n        string metadataIPFSHash,\n        string contentIPFSHash,\n        string gateIPFSHash,\n        address indexed by\n    );\n\n    /**\n     * @notice Edit a file in the smart contract.\n     * This function can only be called by a collaborator\n     * @dev An event `event EditedFile` is also emitted at the end. All the data that is passed as parameters\n     * replaces the data in files mapping.\n     * @param fileId - fileId of the file being edited. Its of the type uint256.\n     * @param _metadataIPFSHash - The IPFS hash of the metadata file.\n     * @param _contentIPFSHash - The IPFS hash of the file's content.\n     * @param _gateIPFSHash - The IPFS hash of the gate file.\n     * @param filetype - This is an enum that can be one of the following: Public / Private / Gated\n     * @param version - a uint256 which tells which version of the key was used to handle the file\n     */\n    function editFile(\n        uint256 fileId,\n        string calldata _metadataIPFSHash,\n        string calldata _contentIPFSHash,\n        string calldata _gateIPFSHash,\n        FileType filetype,\n        uint256 version\n    ) public onlyCollaborator {\n        require(bytes(_metadataIPFSHash).length != 0, \"FV206\");\n        require(bytes(_contentIPFSHash).length != 0, \"FV206\");\n\n        _versionOfKeyVerifierCheck(version);\n\n        if (filetype == FileType.GATED) {\n            require(bytes(_gateIPFSHash).length != 0, \"FV213\");\n        } else {\n            require(bytes(_gateIPFSHash).length == 0, \"FV214\");\n        }\n\n        if (fileId >= _fileIdCounter.current()) {\n            require(false, \"FV207\");\n        }\n\n        files[fileId] = File(\n            _metadataIPFSHash,\n            _contentIPFSHash,\n            _gateIPFSHash,\n            filetype,\n            version\n        );\n        emit EditedFile(\n            fileId,\n            _metadataIPFSHash,\n            _contentIPFSHash,\n            _gateIPFSHash,\n            _msgSender()\n        );\n    }\n\n    /**\n     * `function getFileCount() public view returns (uint256)`\n     * @notice This is a public getter function which returns the current file count\n     * @dev It relies on the _fileIdCounter an instance of Counters.Counter and\n     * doesn't change the state of the contract\n     * @return fileCount The current number of files in the smart contract.\n     */\n    function getFileCount() public view returns (uint256) {\n        return _fileIdCounter.current();\n    }\n\n    event RegisteredCollaboratorKeys(address indexed account);\n\n    /**\n     * @notice This function allows a collaborator to register their DIDs with the contract.\n     * This function can only be called by a collaborator\n     * @dev An event `event RegisteredCollaboratorKeys(address indexed account)` is also emitted at the end\n     * @param viewDid - The DID of the collaborator that can be used to view the data\n     * @param editDid - The DID of the collaborator that can be used to edit the data\n     */\n    function registerCollaboratorKeys(\n        string calldata viewDid,\n        string calldata editDid\n    ) public onlyCollaborator {\n        address sender = _msgSender();\n        _addKey(sender, viewDid, editDid);\n    }\n\n    event RemovedCollaboratorKeys(address indexed account);\n\n    /**\n     * `function removeSelfKeys() public onlyCollaborator returns (void)`\n     * @notice This function removes the sender from the collaboratorKeys mapping.\n     * This function can only be called by a collaborator\n     * @dev It also removes the view and edit DIDs from the collaboratorKeys mapping\n     * An event `event RemovedCollaboratorKeys(address indexed account)` is also emitted at the end\n     */\n    function removeCollaboratorKeys() public onlyCollaborator {\n        address sender = _msgSender();\n        _removeKey(sender);\n    }\n\n    function renounceOwnership() public override onlyOwner {}\n\n    /**\n     * `function getcollaboratorKeysCount() public view returns (uint256)`\n     * @notice This is public function to get all the onborded collaborators of the portal\n     * @return collaboratorKeysCount The number of collaboratorKeys in the club.\n     */\n    function getCollaboratorKeysCount() public view returns (uint256) {\n        return collaboratorKeysCount;\n    }\n\n    event UpdatedKeyVerifiers(\n        bytes32 portalEncryptionKeyVerifier,\n        bytes32 portalDecryptionKeyVerifier,\n        bytes32 memberEncryptionKeyVerifier,\n        bytes32 memberDecryptionKeyVerifier\n    );\n\n    /**\n     * @notice This is public function to update the keyVerifiers of the contract which\n     * This function can only be called by an owner\n     * @param portalEncryptionKeyVerifier - sha256 hash of Portal Encryption Key\n     * @param portalDecryptionKeyVerifier - sha256 hash of Portal Decryption Key\n     * @param memberEncryptionKeyVerifier - sha256 hash of Member Encryption Key\n     * @param memberDecryptionKeyVerifier - sha256 hash of Member Decryption Key\n     */\n    function updateKeyVerifiers(\n        bytes32 portalEncryptionKeyVerifier,\n        bytes32 portalDecryptionKeyVerifier,\n        bytes32 memberEncryptionKeyVerifier,\n        bytes32 memberDecryptionKeyVerifier\n    ) public onlyOwner {\n        _addKeyVerifiers(\n            portalEncryptionKeyVerifier,\n            portalDecryptionKeyVerifier,\n            memberEncryptionKeyVerifier,\n            memberDecryptionKeyVerifier\n        );\n        emit UpdatedKeyVerifiers(\n            portalEncryptionKeyVerifier,\n            portalDecryptionKeyVerifier,\n            memberEncryptionKeyVerifier,\n            memberDecryptionKeyVerifier\n        );\n    }\n\n    function _addKeyVerifiers(\n        bytes32 portalEncryptionKeyVerifier,\n        bytes32 portalDecryptionKeyVerifier,\n        bytes32 memberEncryptionKeyVerifier,\n        bytes32 memberDecryptionKeyVerifier\n    ) internal {\n        require(portalEncryptionKeyVerifier.length != 0, \"FV206\");\n        require(portalDecryptionKeyVerifier.length != 0, \"FV206\");\n        require(memberEncryptionKeyVerifier.length != 0, \"FV206\");\n        require(memberDecryptionKeyVerifier.length != 0, \"FV206\");\n        uint256 verifierId = _keyVerifierCounter;\n        keyVerifiers[verifierId] = PortalKeyVerifiers.KeyVerifier(\n            portalEncryptionKeyVerifier,\n            portalDecryptionKeyVerifier,\n            memberEncryptionKeyVerifier,\n            memberDecryptionKeyVerifier\n        );\n        ++_keyVerifierCounter;\n    }\n\n    /**\n     * `function _msgSender() internal view override(Context, ERC2771Context) returns (address sender)`\n     *\n     * @notice The function is named `_msgSender` and it is `internal` and `view` (i.e. it does not modify the\n     * state of the contract and it does not cost gas). It `overrides` the `_msgSender` function in the\n     * `Context` contract. It returns the address of the sender of the message\n     * @dev This function is required to make the contract gasless and is inherited from ERC2771Context\n     * @return sender the address of the message sender\n     */\n    function _msgSender()\n        internal\n        view\n        override(Context, ERC2771Context)\n        returns (address sender)\n    {\n        return ERC2771Context._msgSender();\n    }\n\n    /**\n     * `function _msgData() internal view override(Context, ERC2771Context) returns (bytes calldata)`\n     *\n     * @notice The function is named `_msgData` and it is `internal` and `view` (i.e. it does not modify the\n     * state of the contract and it does not cost gas). It `overrides` the `_msgData` function in the\n     * `Context` contract. It returns a `bytes calldata` value\n     * @dev This function is required to make the contract gasless and is inherited from ERC2771Context\n     * @return The calldata of the message.\n     */\n    function _msgData()\n        internal\n        view\n        override(Context, ERC2771Context)\n        returns (bytes calldata)\n    {\n        return ERC2771Context._msgData();\n    }\n\n    /**\n     * @notice Sets up the circular linked list for collaborators mapping.\n     * @dev Initial setup step required for kickstarting the collaborator mapping\n     */\n    function _setupCollaborator() internal {\n        collaborators[SENTINEL_COLLABORATOR] = SENTINEL_COLLABORATOR;\n    }\n\n    /**\n     * @notice Adds a new collaborator to the collaborators mapping.\n     *\n     * This function adds a new collaborator address to the collaborators mapping and increments the collaboratorCount.\n     * It checks to ensure that the address is not equal to 0, the SENTINEL_COLLABORATOR, or itself. It also checks to\n     * ensure that the collaborator is not a duplicate.\n     *\n     * @param collaborator The address of the collaborator to add.\n     *\n     */\n    function _addCollaborator(address collaborator) internal {\n        require(\n            collaborator != address(0) &&\n                collaborator != SENTINEL_COLLABORATOR &&\n                collaborator != address(this),\n            \"FV203\"\n        );\n        // No duplicate owners allowed.\n        require(collaborators[collaborator] == address(0), \"FV204\");\n        collaborators[collaborator] = collaborators[SENTINEL_COLLABORATOR];\n        collaborators[SENTINEL_COLLABORATOR] = collaborator;\n        ++collaboratorCount;\n    }\n\n    /**\n     * @notice Removes a key from the collaboratorKeys mapping.\n     *\n     * This function removes an address from the collaboratorKeys mapping and decrements the collaboratorKeysCount. It also emits the\n     * RemovedCollaboratorKeys event. It checks to ensure that the viewDid and editDid strings have a non-zero length.\n     *\n     * @param account The address of the collaborator\n     */\n    function _removeKey(address account) internal {\n        CollaboratorKey memory collaboratorKey = collaboratorKeys[account];\n        require(bytes(collaboratorKey.viewDid).length > 0, \"FV209\");\n        require(bytes(collaboratorKey.editDid).length > 0, \"FV209\");\n        delete collaboratorKeys[account];\n        --collaboratorKeysCount;\n        emit RemovedCollaboratorKeys(account);\n    }\n\n    /**\n     * @notice Adds a new collaborator's keys to the collaboratorKeys mapping.\n     *\n     * This function adds a new member to the collaboratorKeys mapping, increments the collaboratorKeysCount and emits the RegisteredCollaboratorKeys\n     * event. It checks to ensure that the viewDid and editDid strings have a non-zero length.\n     *\n     * @param account The address of the member to add.\n     * @param viewDid - The DID of the collaborator that can be used to view the data\n     * @param editDid - The DID of the collaborator that can be used to edit the data\n     *\n     */\n    function _addKey(\n        address account,\n        string memory viewDid,\n        string memory editDid\n    ) internal {\n        require(bytes(viewDid).length != 0, \"FV201\");\n        require(bytes(editDid).length != 0, \"FV201\");\n        CollaboratorKey memory collaboratorKey = collaboratorKeys[account];\n        require(bytes(collaboratorKey.viewDid).length == 0, \"FV209\");\n        require(bytes(collaboratorKey.editDid).length == 0, \"FV209\");\n\n        collaboratorKeys[account] = CollaboratorKey(viewDid, editDid);\n        collaboratorKeysCount += 1;\n        emit RegisteredCollaboratorKeys(account);\n    }\n\n    /**\n     * `_versionOfKeyVerifierCheck(uint256 _version)` checks if the `_version` is greater than\n     * `_keyVerifierCounter` and if it is, it throws an error\n     * @param _version - The version of the key verifier that you want to check.\n     */\n    function _versionOfKeyVerifierCheck(uint256 _version) internal view {\n        if (_version >= _keyVerifierCounter) {\n            require(false, \"FV208\");\n        }\n    }\n}\n"
    },
    "contracts/Groth16Verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Groth16Verifier {\n\t// Scalar field size\n\tuint256 constant r =\n\t\t21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\t// Base field size\n\tuint256 constant q =\n\t\t21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n\t// Verification Key data\n\tuint256 constant alphax =\n\t\t20491192805390485299153009773594534940189261866228447918068658471970481763042;\n\tuint256 constant alphay =\n\t\t9383485363053290200918347156157836566562967994039712273449902621266178545958;\n\tuint256 constant betax1 =\n\t\t4252822878758300859123897981450591353533073413197771768651442665752259397132;\n\tuint256 constant betax2 =\n\t\t6375614351688725206403948262868962793625744043794305715222011528459656738731;\n\tuint256 constant betay1 =\n\t\t21847035105528745403288232691147584728191162732299865338377159692350059136679;\n\tuint256 constant betay2 =\n\t\t10505242626370262277552901082094356697409835680220590971873171140371331206856;\n\tuint256 constant gammax1 =\n\t\t11559732032986387107991004021392285783925812861821192530917403151452391805634;\n\tuint256 constant gammax2 =\n\t\t10857046999023057135944570762232829481370756359578518086990519993285655852781;\n\tuint256 constant gammay1 =\n\t\t4082367875863433681332203403145435568316851327593401208105741076214120093531;\n\tuint256 constant gammay2 =\n\t\t8495653923123431417604973247489272438418190587263600148770280649306958101930;\n\tuint256 constant deltax1 =\n\t\t4794378188555673810018158797263945613117081424700154854974240721894252090534;\n\tuint256 constant deltax2 =\n\t\t1816911282723953521360374096804693609948256596921895265929104078200823204675;\n\tuint256 constant deltay1 =\n\t\t4822598240965235353021859310978490456254180072341966996061361969858340984511;\n\tuint256 constant deltay2 =\n\t\t13543378357184474310383646423534605062703850124878450029441667582061275654866;\n\n\tuint256 constant IC0x =\n\t\t7039163794843290796256368468693852992261864980639380847782867461741038210431;\n\tuint256 constant IC0y =\n\t\t13828571545952070419695572439672637697093967550127663217094587479939756801713;\n\n\tuint256 constant IC1x =\n\t\t3958090907019850444580447271310783643067855398231992297257715727710216995446;\n\tuint256 constant IC1y =\n\t\t20221946439601599894288820734713434259239717191029254240067234373135565758177;\n\n\tuint256 constant IC2x =\n\t\t900186639711238933493055667378009920193627212372904879368486442415809327595;\n\tuint256 constant IC2y =\n\t\t2326167641766524616999631967433198170614424673993051767085816973791951172320;\n\n\tuint256 constant IC3x =\n\t\t5036413725381298640320115097177392324444247429122196014822193539177279161834;\n\tuint256 constant IC3y =\n\t\t16915948281029825623174724126850423768748230097781953657414920017958567938481;\n\n\tuint256 constant IC4x =\n\t\t18760100143371695362362583151699410223835931838504964976371030235483771799520;\n\tuint256 constant IC4y =\n\t\t11050897648840559830340797268632494985552806330900971650426635140540632129623;\n\n\tuint256 constant IC5x =\n\t\t14405103043934777929451041926853384737748587264397789238453021115804714011027;\n\tuint256 constant IC5y =\n\t\t17654525523246776275961068512159018488399387144246684730694339431289852689612;\n\n\tuint256 constant IC6x =\n\t\t8723869934697142623491762263289398094319535893464503540125898389370968107859;\n\tuint256 constant IC6y =\n\t\t6562444046746975238614247431088671155226534237756214900132774223548393484900;\n\n\tuint256 constant IC7x =\n\t\t14577478605943949020672432197678273024089978103276775373202577864795436168402;\n\tuint256 constant IC7y =\n\t\t20868380911669423225158693169242758989558229682271980505657366061586596203338;\n\n\tuint256 constant IC8x =\n\t\t15078791307200682406383940510187595016164044832563024269891293768166347461344;\n\tuint256 constant IC8y =\n\t\t13807879254500296471557402479543820453954075404741718297177665886866496451391;\n\n\tuint256 constant IC9x =\n\t\t11961110457054262187040141268827975035460766426109310097612340764580611314242;\n\tuint256 constant IC9y =\n\t\t648031620139716874034542002574123681367629070550974595278392168004036814626;\n\n\tuint256 constant IC10x =\n\t\t9897786420777014154834245148124872045575237833648028105961996898423566286793;\n\tuint256 constant IC10y =\n\t\t10942250463782575990311669310939232003635777350050348004971415243722694683862;\n\n\tuint256 constant IC11x =\n\t\t21768976691153943693253939674737520933075287952326155542834234684045105263955;\n\tuint256 constant IC11y =\n\t\t2652628038258207868440308689934020510765602358527332281459263595352308874872;\n\n\tuint256 constant IC12x =\n\t\t10579889892022441902715761343940775692321155123038188581132868576263856691960;\n\tuint256 constant IC12y =\n\t\t14197080288473739214766468387110821163678798975745451452929084680507366969089;\n\n\tuint256 constant IC13x =\n\t\t17381487274016777148244396779385401991045642828052327241661444508026488993960;\n\tuint256 constant IC13y =\n\t\t12631141756649305162072161190046426727112068887466313087474366448379889938290;\n\n\tuint256 constant IC14x =\n\t\t13935047382751423896533075574654791455853724928466459591893970338304052339429;\n\tuint256 constant IC14y =\n\t\t6824865220976543574218366346391934951925243253294023634161017592510424936549;\n\n\tuint256 constant IC15x =\n\t\t7031992312358334117229960826366500136698824958913380375057168422867887208482;\n\tuint256 constant IC15y =\n\t\t6487726177217344454795293919275011847002886774229625835362883818222058658917;\n\n\tuint256 constant IC16x =\n\t\t32761952607172566377921792852655350243312728025797797731884919650955995978;\n\tuint256 constant IC16y =\n\t\t17109740037766941001038815791052639848028856032033398873318266457482577886649;\n\n\tuint256 constant IC17x =\n\t\t5148130823680965556573321200326358804854949261914205931196224467597274599399;\n\tuint256 constant IC17y =\n\t\t17786165933748885174698871854113633988020047930367652317579732342918892135076;\n\n\tuint256 constant IC18x =\n\t\t19132395236354116173686960242674593409872273373618210170105548787911478039676;\n\tuint256 constant IC18y =\n\t\t13128673728382375315191668017332103847318829241457370626993176402741448018866;\n\n\tuint256 constant IC19x =\n\t\t14279232715058070388045405059532116192488308995813346048366203712476135182708;\n\tuint256 constant IC19y =\n\t\t15194615736824271563039224473810596003691641177247333143890653748759024086797;\n\n\tuint256 constant IC20x =\n\t\t9955090722504979957069720304999125823978111318362496584519854575527608185162;\n\tuint256 constant IC20y =\n\t\t5794103785028496675031047406750626512072617762810766655823567669958439141907;\n\n\tuint256 constant IC21x =\n\t\t3093386023754979021969916793626732114241059635051234406414231194529079272032;\n\tuint256 constant IC21y =\n\t\t2726333648975816401517500089384058227785233536677037001841489035806732587931;\n\n\tuint256 constant IC22x =\n\t\t5277410462435782523915882980275775886349488617157850699431034750288036800613;\n\tuint256 constant IC22y =\n\t\t21607346138964363953763925149731352915511002970774217667749452112345555034956;\n\n\tuint256 constant IC23x =\n\t\t2882073216919257197946498011741429525374768355767062401579097340303609014667;\n\tuint256 constant IC23y =\n\t\t13336208254651518889575781043861573326120722149864211966571295065261003981732;\n\n\tuint256 constant IC24x =\n\t\t16518085772523452403713249212239346119989769943791821955471370367814804849274;\n\tuint256 constant IC24y =\n\t\t3163851008551205343892721959924291514513839424028748364301581737083684712635;\n\n\tuint256 constant IC25x =\n\t\t21443140829801323335830440272589422531303604169183393653690045415169893110317;\n\tuint256 constant IC25y =\n\t\t11843677807581613645245376500039550313868511109982120780557566436801551936632;\n\n\tuint256 constant IC26x =\n\t\t9011343512724109228637988929452301928814416148302399365691495043540007452711;\n\tuint256 constant IC26y =\n\t\t19203719374228430540624285138844258546893532214993666117722702463877026204624;\n\n\tuint256 constant IC27x =\n\t\t12282563786492051221220863019504107834872987144162405093912833624832473504126;\n\tuint256 constant IC27y =\n\t\t2098404497662286606968957419285970045028044455644658720985187205946176225636;\n\n\tuint256 constant IC28x =\n\t\t1990701565738088758270472967471263340707808628204302356692995713089340295959;\n\tuint256 constant IC28y =\n\t\t4710902959112092813812405997875645709469153185247079786406984810436621334836;\n\n\tuint256 constant IC29x =\n\t\t20358882933388981503171778761697392336011378779059025555927722043477769063258;\n\tuint256 constant IC29y =\n\t\t19015855458316650610909766042056506990773552974154423789621320056338171324109;\n\n\tuint256 constant IC30x =\n\t\t20882010929117143317945388885678484675687595287997043750607534940060968021588;\n\tuint256 constant IC30y =\n\t\t11586557172082174037613559244105184201710114582175280732260566723406709924275;\n\n\tuint256 constant IC31x =\n\t\t9866308320093007323457785354472236077116309736444536950583247217505300484593;\n\tuint256 constant IC31y =\n\t\t7621726862256096662846253511430079218096624239819015602672239587875065773680;\n\n\tuint256 constant IC32x =\n\t\t14027123489779385457612700332560563436358522575256251872455086560940806515518;\n\tuint256 constant IC32y =\n\t\t10938955322537907189548948078384029109133599816409669950598646265343304376683;\n\n\tuint256 constant IC33x =\n\t\t8185779524540657541561125117577265603809435796152263318353366879537563587361;\n\tuint256 constant IC33y =\n\t\t7022890698869206227386505409956869964786133909878013184769185704625348906859;\n\n\tuint256 constant IC34x =\n\t\t11611413113751908909193648245064739218553980961929170910199270975967104957038;\n\tuint256 constant IC34y =\n\t\t18994807587760619856245913328685591005051029724453337667407306111138944756694;\n\n\tuint256 constant IC35x =\n\t\t200383746952988761639379177517104787510472386926528110614397950418667358661;\n\tuint256 constant IC35y =\n\t\t20007848431425763869830663340890269703980870987344402378604194352912831137056;\n\n\tuint256 constant IC36x =\n\t\t328413860030399674842447170312944751562586291423774720425356928068580343472;\n\tuint256 constant IC36y =\n\t\t5189648959630633293821012021210812639351882790811543893302480708749969871675;\n\n\tuint256 constant IC37x =\n\t\t6012328917803371026931141367320642434394368982571440096775691385288621172219;\n\tuint256 constant IC37y =\n\t\t3144007704082241276171331516247837779546266689067323035946808770824524079278;\n\n\tuint256 constant IC38x =\n\t\t6432946433062452526687536616554972830856614963273241146116338471741671687252;\n\tuint256 constant IC38y =\n\t\t15585047391247849588392219751347369098681511169371119693472990059654876497118;\n\n\t// Memory data\n\tuint16 constant pVk = 0;\n\tuint16 constant pPairing = 128;\n\n\tuint16 constant pLastMem = 896;\n\n\tfunction verifyProof(\n\t\tuint[2] calldata _pA,\n\t\tuint[2][2] calldata _pB,\n\t\tuint[2] calldata _pC,\n\t\tuint[38] calldata _pubSignals\n\t) public view returns (bool) {\n\t\tassembly {\n\t\t\tfunction checkField(v) {\n\t\t\t\tif iszero(lt(v, q)) {\n\t\t\t\t\tmstore(0, 0)\n\t\t\t\t\treturn(0, 0x20)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// G1 function to multiply a G1 value(x,y) to value in an address\n\t\t\tfunction g1_mulAccC(pR, x, y, s) {\n\t\t\t\tlet success\n\t\t\t\tlet mIn := mload(0x40)\n\t\t\t\tmstore(mIn, x)\n\t\t\t\tmstore(add(mIn, 32), y)\n\t\t\t\tmstore(add(mIn, 64), s)\n\n\t\t\t\tsuccess := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n\t\t\t\tif iszero(success) {\n\t\t\t\t\tmstore(0, 0)\n\t\t\t\t\treturn(0, 0x20)\n\t\t\t\t}\n\n\t\t\t\tmstore(add(mIn, 64), mload(pR))\n\t\t\t\tmstore(add(mIn, 96), mload(add(pR, 32)))\n\n\t\t\t\tsuccess := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n\t\t\t\tif iszero(success) {\n\t\t\t\t\tmstore(0, 0)\n\t\t\t\t\treturn(0, 0x20)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n\t\t\t\tlet _pPairing := add(pMem, pPairing)\n\t\t\t\tlet _pVk := add(pMem, pVk)\n\n\t\t\t\tmstore(_pVk, IC0x)\n\t\t\t\tmstore(add(_pVk, 32), IC0y)\n\n\t\t\t\t// Compute the linear combination vk_x\n\n\t\t\t\tg1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n\n\t\t\t\tg1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\n\n\t\t\t\tg1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\n\n\t\t\t\tg1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))\n\n\t\t\t\tg1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))\n\n\t\t\t\tg1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))\n\n\t\t\t\tg1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))\n\n\t\t\t\tg1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))\n\n\t\t\t\tg1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC10x,\n\t\t\t\t\tIC10y,\n\t\t\t\t\tcalldataload(add(pubSignals, 288))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC11x,\n\t\t\t\t\tIC11y,\n\t\t\t\t\tcalldataload(add(pubSignals, 320))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC12x,\n\t\t\t\t\tIC12y,\n\t\t\t\t\tcalldataload(add(pubSignals, 352))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC13x,\n\t\t\t\t\tIC13y,\n\t\t\t\t\tcalldataload(add(pubSignals, 384))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC14x,\n\t\t\t\t\tIC14y,\n\t\t\t\t\tcalldataload(add(pubSignals, 416))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC15x,\n\t\t\t\t\tIC15y,\n\t\t\t\t\tcalldataload(add(pubSignals, 448))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC16x,\n\t\t\t\t\tIC16y,\n\t\t\t\t\tcalldataload(add(pubSignals, 480))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC17x,\n\t\t\t\t\tIC17y,\n\t\t\t\t\tcalldataload(add(pubSignals, 512))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC18x,\n\t\t\t\t\tIC18y,\n\t\t\t\t\tcalldataload(add(pubSignals, 544))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC19x,\n\t\t\t\t\tIC19y,\n\t\t\t\t\tcalldataload(add(pubSignals, 576))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC20x,\n\t\t\t\t\tIC20y,\n\t\t\t\t\tcalldataload(add(pubSignals, 608))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC21x,\n\t\t\t\t\tIC21y,\n\t\t\t\t\tcalldataload(add(pubSignals, 640))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC22x,\n\t\t\t\t\tIC22y,\n\t\t\t\t\tcalldataload(add(pubSignals, 672))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC23x,\n\t\t\t\t\tIC23y,\n\t\t\t\t\tcalldataload(add(pubSignals, 704))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC24x,\n\t\t\t\t\tIC24y,\n\t\t\t\t\tcalldataload(add(pubSignals, 736))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC25x,\n\t\t\t\t\tIC25y,\n\t\t\t\t\tcalldataload(add(pubSignals, 768))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC26x,\n\t\t\t\t\tIC26y,\n\t\t\t\t\tcalldataload(add(pubSignals, 800))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC27x,\n\t\t\t\t\tIC27y,\n\t\t\t\t\tcalldataload(add(pubSignals, 832))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC28x,\n\t\t\t\t\tIC28y,\n\t\t\t\t\tcalldataload(add(pubSignals, 864))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC29x,\n\t\t\t\t\tIC29y,\n\t\t\t\t\tcalldataload(add(pubSignals, 896))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC30x,\n\t\t\t\t\tIC30y,\n\t\t\t\t\tcalldataload(add(pubSignals, 928))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC31x,\n\t\t\t\t\tIC31y,\n\t\t\t\t\tcalldataload(add(pubSignals, 960))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC32x,\n\t\t\t\t\tIC32y,\n\t\t\t\t\tcalldataload(add(pubSignals, 992))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC33x,\n\t\t\t\t\tIC33y,\n\t\t\t\t\tcalldataload(add(pubSignals, 1024))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC34x,\n\t\t\t\t\tIC34y,\n\t\t\t\t\tcalldataload(add(pubSignals, 1056))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC35x,\n\t\t\t\t\tIC35y,\n\t\t\t\t\tcalldataload(add(pubSignals, 1088))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC36x,\n\t\t\t\t\tIC36y,\n\t\t\t\t\tcalldataload(add(pubSignals, 1120))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC37x,\n\t\t\t\t\tIC37y,\n\t\t\t\t\tcalldataload(add(pubSignals, 1152))\n\t\t\t\t)\n\n\t\t\t\tg1_mulAccC(\n\t\t\t\t\t_pVk,\n\t\t\t\t\tIC38x,\n\t\t\t\t\tIC38y,\n\t\t\t\t\tcalldataload(add(pubSignals, 1184))\n\t\t\t\t)\n\n\t\t\t\t// -A\n\t\t\t\tmstore(_pPairing, calldataload(pA))\n\t\t\t\tmstore(\n\t\t\t\t\tadd(_pPairing, 32),\n\t\t\t\t\tmod(sub(q, calldataload(add(pA, 32))), q)\n\t\t\t\t)\n\n\t\t\t\t// B\n\t\t\t\tmstore(add(_pPairing, 64), calldataload(pB))\n\t\t\t\tmstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n\t\t\t\tmstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n\t\t\t\tmstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n\t\t\t\t// alpha1\n\t\t\t\tmstore(add(_pPairing, 192), alphax)\n\t\t\t\tmstore(add(_pPairing, 224), alphay)\n\n\t\t\t\t// beta2\n\t\t\t\tmstore(add(_pPairing, 256), betax1)\n\t\t\t\tmstore(add(_pPairing, 288), betax2)\n\t\t\t\tmstore(add(_pPairing, 320), betay1)\n\t\t\t\tmstore(add(_pPairing, 352), betay2)\n\n\t\t\t\t// vk_x\n\t\t\t\tmstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n\t\t\t\tmstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n\t\t\t\t// gamma2\n\t\t\t\tmstore(add(_pPairing, 448), gammax1)\n\t\t\t\tmstore(add(_pPairing, 480), gammax2)\n\t\t\t\tmstore(add(_pPairing, 512), gammay1)\n\t\t\t\tmstore(add(_pPairing, 544), gammay2)\n\n\t\t\t\t// C\n\t\t\t\tmstore(add(_pPairing, 576), calldataload(pC))\n\t\t\t\tmstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n\t\t\t\t// delta2\n\t\t\t\tmstore(add(_pPairing, 640), deltax1)\n\t\t\t\tmstore(add(_pPairing, 672), deltax2)\n\t\t\t\tmstore(add(_pPairing, 704), deltay1)\n\t\t\t\tmstore(add(_pPairing, 736), deltay2)\n\n\t\t\t\tlet success := staticcall(\n\t\t\t\t\tsub(gas(), 2000),\n\t\t\t\t\t8,\n\t\t\t\t\t_pPairing,\n\t\t\t\t\t768,\n\t\t\t\t\t_pPairing,\n\t\t\t\t\t0x20\n\t\t\t\t)\n\n\t\t\t\tisOk := and(success, mload(_pPairing))\n\t\t\t}\n\n\t\t\tlet pMem := mload(0x40)\n\t\t\tmstore(0x40, add(pMem, pLastMem))\n\n\t\t\t// Validate that all evaluations ∈ F\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 0)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 32)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 64)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 96)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 128)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 160)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 192)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 224)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 256)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 288)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 320)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 352)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 384)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 416)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 448)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 480)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 512)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 544)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 576)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 608)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 640)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 672)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 704)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 736)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 768)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 800)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 832)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 864)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 896)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 928)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 960)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 992)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 1024)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 1056)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 1088)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 1120)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 1152)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 1184)))\n\n\t\t\tcheckField(calldataload(add(_pubSignals, 1216)))\n\n\t\t\t// Validate all evaluations\n\t\t\tlet isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n\t\t\tmstore(0, isValid)\n\t\t\treturn(0, 0x20)\n\t\t}\n\t}\n}\n"
    },
    "contracts/structs/PortalKeyVerifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary PortalKeyVerifiers {\n    struct KeyVerifier {\n        bytes32 portalEncryptionKeyVerifier;\n        bytes32 portalDecryptionKeyVerifier;\n        bytes32 memberEncryptionKeyVerifier;\n        bytes32 memberDecryptionKeyVerifier;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}